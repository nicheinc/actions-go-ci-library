name: CI
# Restrict permissions to just reading contents.
permissions:
  contents: read

# This action is solely available as a re-usable action to be called from other
# workflows.
on:
  workflow_call:
    secrets:
      NPM_WRITE_TOKEN:
        required: true
jobs:
  # Retrieve the minimum Go version from go.mod and output a matrix of all Go
  # versions released since.
  go-versions:
    name: Check Go Versions
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.versions.outputs.matrix }}
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v4

      - name: Set Go Versions
        id: versions
        # go-version-action@v1.1.20
        uses: arnested/go-version-action@b4aefb809febc150eb645efd31b1a3fd50b2068a

  # Run unit tests and linters with each supported Go version.
  unit-test-and-lint:
    name: Unit test and lint with Go ${{ matrix.go }}
    runs-on: ubuntu-latest
    needs: go-versions
    strategy:
      fail-fast: false
      matrix:
        go: ${{ fromJSON(needs.go-versions.outputs.matrix) }}
    steps:
      - name: Checkout code
        id: checkout
        uses: actions/checkout@v4

      - name: Install Go
        id: install-go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go }}

      - name: Configure private Go modules
        id: configure-private-modules
        run: |
          # Tell go that github.com/nicheinc modules can't always be found on
          # the public Go module mirror.
          go env -w GOPRIVATE=github.com/nicheinc

          # Equip git with the NPM_WRITE_TOKEN that has permissions to read the
          # contents of private repos in the nicheinc GitHub org.
          git config --global --add url.https://${{ secrets.NPM_WRITE_TOKEN }}@github.com/.insteadOf https://github.com/

      - name: Test
        id: test
        uses: robherley/go-test-action@b19f6aadabfb1ad85079065b21aa2af132466468
        with:
          testArguments: '-v -race ./...'

      - name: Vet
        id: vet
        run: |
          go vet ./...

      - name: gofumpt
        id: run-gofumpt
        run: |
          # gofumpt@v0.7.0
          go run mvdan.cc/gofumpt@86bffd62437a3c437c0b84d5d5ab244824e762fc -l -w .

          # If any files would be changed by running gofumpt, then fail the
          # check.
          if [[ $(git status --porcelain) ]]; then
            echo "The above files are not formatted with gofumpt."
            echo "Please run 'go run mvdan.cc/gofumpt -l -w .' and commit the changes."
            exit 1
          fi

  # Ensure code changes and go.mod are compatible.
  validate-semver:
    name: Validate semver
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        id: checkout
        uses: actions/checkout@v4

      - name: Install Go
        id: install-go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Configure private Go modules
        id: configure-private-modules
        run: |
          # Tell go that github.com/nicheinc modules can't always be found on
          # the public Go module mirror.
          go env -w GOPRIVATE=github.com/nicheinc

          # Equip git with the NPM_WRITE_TOKEN that has permissions to read the
          # contents of private repos in the nicheinc GitHub org.
          git config --global --add url.https://${{ secrets.NPM_WRITE_TOKEN }}@github.com/.insteadOf https://github.com/

      # We could just run gorelease for this step, using its exit code to
      # determine success or failure. However, gorelease can exit non-zero for
      # reasons other than breaking changes, e.g. due to missing go.sum entries
      # or retracted dependencies, which is more pedantic than we want to be.
      # Instead, we'll capture the gorelease output and parse it for
      # semver-related info.
      - name: Use gorelease to detect breaking changes
        id: gorelease
        run: |
          results="$(go run golang.org/x/exp/cmd/gorelease@latest)"
          suggested_version_regex='Suggested version: (v[0-9]+\.[0-9]+\.[0-9]+)'

          # Print the gorelease results for debugging purposes.
          echo "::group::gorelease output"
          echo "${results}"
          echo "::endgroup::"
          
          # If gorelease detects incompatible changes with the inferred base
          # version, then we should flag the situation as requiring more
          # attention from the developer. This check will exclude _other_
          # reasons why gorelease may not have been able to suggest a version,
          # such as missing go.sum entries or retracted dependencies. Those
          # should fall into the else case of this statement.
          if [[ ${results} =~ "Incompatible changes were detected" ]]; then
            echo "This PR may contain breaking changes incompatible with its module version. See gorelease output for details."
            exit 1
          # If gorelease can suggest a version, that means either the proposed
          # change is a minor or patch increment OR the developer correctly
          # incremented the module's major version to account for their
          # breaking change.
          elif [[ ${results} =~ ${suggested_version_regex} ]]; then
            suggested_version="${BASH_REMATCH[1]}"
            echo "This PR's changes are compatible with its module version. üëçÔ∏è"
            echo "Suggested version: ${suggested_version}"
          else 
            echo "Could not determine validity of versioning. See gorelease output for details."
          fi


  # This job provides a single target that libraries can use for required
  # status checks for branch protection rulesets. By combining all the required
  # checks into this job, it allows us to change the set of required checks
  # without needing to update the branch protection rules in all the repos
  # using this action.
  required-check:
    name: Verify that all required jobs passed
    runs-on: ubuntu-latest
    # Generally speaking, we don't require that semver be respected in order to
    # consider CI as passed. Though we generally do follow semver and want to
    # be alerted in CI if a PR would break it, that's primarily to avoid
    # inadvertently breaking semver. If we are purposefully breaking semver, we
    # should be able to do so.
    needs: [unit-test-and-lint]
    steps:
      - name: Verify unit tests and linting passed with all Go versions
        run: |
          result="${{ needs.unit-test-and-lint.result }}"
          if [[ ${result} == 'failure' ]]; then
            exit 1
          fi

